import * as React from 'react';
import * as ReactDom from 'react-dom';
import Router, { CutoverEvent } from './Router';
import { composeAsync } from 'grey-group-function';
import { Location } from 'history';
import { IRouteProps } from './Route';
import PageBasis from './PageBasis';

export class SwitchState {

    /** 路由器数据 */
    public location: Location = Router.history.location;
}

export interface ISwitchProps {

    /** 默认地址 */
    default?: number;

    /** 样式 */
    className?: string;
}

/** 缓存数据接口 */
export interface ICache {

    /** react 实例（高阶组件） */
    rdom: React.Component<React.DOMAttributes<never>, any, any>;

    /** react 实例（真实） */
    rdomReal?: PageBasis;

    /** 渲染的根 */
    rootDom: HTMLDivElement;

    /** 路由参数 */
    props: IRouteProps;
}

export default class Switch extends React.PureComponent<ISwitchProps, SwitchState> {

    /** 缓存页面 */
    private cachePage: Map<any, ICache>;

    /** 是否被卸载 */
    private isUnmount: boolean = false;

    constructor(props: any) {
        super(props)
        this.state = new SwitchState();
        this.cachePage = new Map();
        Router.on(CutoverEvent.TYPE, this.onCutoverHandler);
    }

    /** 子级数组 */
    private get childrenList(): any[] {
        return Array.isArray(this.props.children) ? this.props.children : [this.props.children];
    }

    public componentDidMount() {
        Router.on(CutoverEvent.TYPE, this.onCutoverHandler);
        this.renderPage();
    }

    public componentWillUnmount() {
        Router.off(CutoverEvent.TYPE, this.onCutoverHandler);
        this.isUnmount = true;
        this.distinctCache();
    }

    public componentDidUpdate() {
        this.renderPage();
    }

    public render() {
        return <div className={`grey-react-router-switch${this.props.className ? ` ${this.props.className}` : ''}`} />;
    }

    /** 寻找可以显示页面 */
    private doSearchPage = () => {
        const list = this.childrenList;
        for (const i in list) {
            if (this.isShow(list[i].props.path, list[i].props.exact)) {
                return list[i].props;
            }
        }
        this.defaultJump();
    }

    /** 创建节点 / 或者重缓存获取节点 */
    private doCreateNode = (props: IRouteProps) => {
        return new Promise((resolve: (value: ICache | undefined) => void) => {
            if (props.path && this.cachePage.has(props.path)) {
                const page = this.cachePage.get(props.path) as ICache;
                if (page.rdomReal && page.rdomReal.renewRender) {
                    page.rdomReal.renewRender();
                }
                resolve(page);
            } else {
                const rootDom = document.createElement('div');
                const cache: ICache = { props, rootDom } as ICache
                ReactDom.render(React.createElement(props.component as any, {
                    ref: this.refCallback(cache, resolve),
                    refReal: this.refRealCallback(cache),
                }), rootDom);
            }
        });
    }

    /** 清除 不用缓存的 页面 */
    private doDistinctAll = (cache: ICache) => {
        this.cachePage.forEach((value, key) => {
            // 发现是当前页面不在处理
            if (cache && cache.rdom === value.rdom) {
                return;
            }

            // 判断当前页面是否缓存
            value.rootDom.appendChild(ReactDom.findDOMNode(value.rdom) as Element);
            if (!value.props.cache) {
                ReactDom.unmountComponentAtNode(value.rootDom);
                this.cachePage.delete(key);// 清理缓存
            }
        })
        return cache;
    }

    /** 显示节点 */
    private doShowNode = (cache: ICache) => {
        const tdom: Element = ReactDom.findDOMNode(this) as Element; // 获取容器
        const cdom: Element = ReactDom.findDOMNode(cache.rdom) as Element; // 获取显示对象
        tdom.childNodes.forEach((value) => tdom.removeChild(value)); // 清理容器
        tdom.appendChild(cdom);
        return cache;
    }

    /** 清除所有 缓存 */
    private distinctCache = () => {
        this.cachePage.forEach((value, key) => {
            value.rootDom.appendChild(ReactDom.findDOMNode(value.rdom) as Element);
            ReactDom.unmountComponentAtNode(value.rootDom);
            this.cachePage.delete(key);// 清理缓存
        })
    }

    /** 判断是否可以显示 */
    private isShow = (path: string, exact: boolean): boolean => {

        // 无路径参数 直接展示
        if (!path) {
            return true;
        }

        const pathname = this.state.location.pathname;
        if (!pathname) {
            return false;
        }

        // 是否严格匹配
        if (exact) {
            return path === pathname;
        } else {
            return pathname.indexOf(path) === 0;
        }
    }

    /** 默认跳转 */
    private defaultJump = () => {
        setTimeout(() => {
            // 如果被卸载就不做处理
            if (this.isUnmount) {
                return;
            }

            if (this.props.default || this.props.default === 0) {
                const children = this.childrenList[this.props.default];
                if (children) {
                    const props: IRouteProps = children.props;
                    Router.history.replace(props.path);
                }
            }
        }, 100)
    }

    /** 获取真实实例回调（解决高阶组件不能使用 ref 问题） */
    private refRealCallback = (cache: ICache) => (e: PageBasis) => {
        cache.rdomReal = e;
    }

    /** 获取组件实例的回调 */
    private refCallback = (cache: ICache, resolve: (value: ICache | undefined) => void) => (e: React.Component<React.DOMAttributes<never>, any, any> | null) => {
        if (e) {
            cache.rdom = e;
            this.cachePage.set(cache.props.path, cache);
            resolve(cache);
        }
    }

    /** 渲染页面 */
    private renderPage = composeAsync(
        this.doSearchPage,
        this.doCreateNode,
        this.doDistinctAll,
        this.doShowNode,
    );

    /** 路由切换时候 */
    private onCutoverHandler = (e: CutoverEvent) => {
        const location = e.location;
        this.setState({ location });
    }
}

