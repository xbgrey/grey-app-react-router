import * as React from 'react';
import * as ReactDom from 'react-dom';
import Router, { CutoverEvent } from './Router';
import { composeAsync } from 'grey-group-function';
import { Location } from 'history';
import { IRouteProps } from './Route';

export class SwitchState {

    /** 路由器数据 */
    public location: Location = Router.history.location;
}

export interface ISwitchProps {

    /** 默认地址 */
    default?: number;

    /** 样式 */
    className?: string;
}

export interface ICache {

    /** react 实例 */
    rdom: React.Component<React.DOMAttributes<never>, any, any>;

    /** 渲染的根 */
    rootDom: HTMLDivElement;

    /** 路由参数 */
    props: IRouteProps;
}

export default class Switch extends React.PureComponent<ISwitchProps, SwitchState> {

    /** 缓存页面 */
    private cachePage: Map<any, ICache>;

    /** 是否被卸载 */
    private isUnmount: boolean = false;

    constructor(props: any) {
        super(props)
        this.state = new SwitchState();
        this.cachePage = new Map();
        Router.on(CutoverEvent.TYPE, this.onCutoverHandler);
    }

    /** 子级数组 */
    private get childrenList(): any[] {
        return Array.isArray(this.props.children) ? this.props.children : [this.props.children];
    }

    public componentDidMount() {
        Router.on(CutoverEvent.TYPE, this.onCutoverHandler);
        this.renderPage();
    }

    public componentWillUnmount() {
        Router.off(CutoverEvent.TYPE, this.onCutoverHandler);
        this.isUnmount = true;
        this.distinctCache();
    }

    public componentDidUpdate() {
        this.renderPage();
    }

    public render() {
        return <div className={`grey-react-router-switch${this.props.className ? ` ${this.props.className}` : ''}`} />;
    }

    /** 寻找可以显示页面 */
    private doSearchPage = () => {
        const list = this.childrenList;
        for (const i in list) {
            if (this.isShow(list[i].props.path, list[i].props.exact)) {
                return list[i].props;
            }
        }
        this.defaultJump();
    }

    /** 创建节点 / 或者重缓存获取节点 */
    private doCreateNode = (props: IRouteProps) => {
        return new Promise((resolve: (value: ICache | undefined) => void) => {

            if (props.path && this.cachePage.has(props.path)) {
                resolve(this.cachePage.get(props.path));
            } else {
                const rootDom = document.createElement('div');
                ReactDom.render(
                    React.createElement(props.component as any, {
                        ref: e => {
                            if (e) {
                                const cache: ICache = { rdom: e, props, rootDom }
                                this.cachePage.set(props.path, cache);
                                resolve(cache);
                            }
                        }
                    }),
                    rootDom
                );
            }
        });
    }

    /** 清除 不用缓存的 页面 */
    private doDistinctAll = (cache: ICache) => {
        this.cachePage.forEach((value, key) => {
            // 发现是当前页面不在处理
            if (cache && cache.rdom === value.rdom) {
                return;
            }

            // 判断当前页面是否缓存
            value.rootDom.appendChild(ReactDom.findDOMNode(value.rdom) as Element);
            if (!value.props.cache) {
                ReactDom.unmountComponentAtNode(value.rootDom);
                this.cachePage.delete(key);// 清理缓存
            }
        })
        return cache;
    }

    /** 显示节点 */
    private doShowNode = (cache: ICache) => {
        const tdom: Element = ReactDom.findDOMNode(this) as Element;
        const cdom: Element = ReactDom.findDOMNode(cache.rdom) as Element;
        tdom.childNodes.forEach((value) => tdom.removeChild(value));
        // (tdom.parentElement as Element).insertBefore(cdom, tdom);
        tdom.appendChild(cdom);
        return cache;
    }

    /** 清除所有 缓存 */
    private distinctCache = () => {
        this.cachePage.forEach((value, key) => {
            value.rootDom.appendChild(ReactDom.findDOMNode(value.rdom) as Element);
            ReactDom.unmountComponentAtNode(value.rootDom);
            this.cachePage.delete(key);// 清理缓存
        })
    }

    /** 判断是否可以显示 */
    private isShow = (path: string, exact: boolean): boolean => {

        // 无路径参数 直接展示
        if (!path) {
            return true;
        }

        const pathname = this.state.location.pathname;
        if (!pathname) {
            return false;
        }

        // 是否严格匹配
        if (exact) {
            return path === pathname;
        } else {
            return pathname.indexOf(path) === 0;
        }
    }

    /** 默认跳转 */
    private defaultJump = () => {
        setTimeout(() => {
            if(this.isUnmount){
                return;
            }
            
            if (this.props.default || this.props.default === 0) {
                const children = this.childrenList[this.props.default];
                if (children) {
                    const props: IRouteProps = children.props;
                    Router.history.replace(props.path);
                }
            }
        }, 100)
    }

    /** 渲染页面 */
    private renderPage = composeAsync(
        this.doSearchPage,
        this.doCreateNode,
        this.doDistinctAll,
        this.doShowNode,
    );

    /** 路由切换时候 */
    private onCutoverHandler = (e: CutoverEvent) => {
        const location = e.location;
        this.setState({ location });
    }
}

